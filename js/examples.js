var basic_ex = 
  '(λx.x + x + 1) 2'

var dfg_ex = 
  '(λx.λy.(x + x) + (y + y)) (deref ({0})) 2'

var link_ex = 
  'let c = {0} in\n'
+ 'let _ = (λx.λy.(x +x)+(y +y)) (deref c) 2 in\n'
+ 'link c {1}'

var max_ex = 
  'let max = λx.λy.if x <= y then y else x in\n'
+ '\n'
+ 'let x = {1} in\n'
+ 'let y = {2} in\n'
+ 'let m = max (deref x) (deref y) in\n'
+ 'step;\n'
+ 'link x 3;\n'
+ 'step;\n'
+ 'm';

var alt_ex =
  'let state_machine = λinit. λtrans. λinp.\n'
+ '  let state = {init} in\n'
+ '  link state (trans (deref state) inp);\n'
+ '  state\n'
+ 'in\n'
+ '\n'
+ 'let alt = state_machine 1 (λs.λ_. 1 - (deref s)) 0 in\n'
+ 'let sum = λinp. state_machine 0 (λs.λi. i + (deref s)) inp in\n'
+ 'let alt_sum = sum (deref alt) in\n' 
+ 'step;\n' 
+ 'step;\n' 
+ 'step;\n' 
+ 'peek alt_sum'; 

var fir_ex = 
  'let nil = 0 in\n' 
+ 'let fir = λx. λfs.\n' 
+ '  let aux = rec g. λx. λsum. λfs.\n' 
+ '    if fs <= nil\n' 
+ '    then \n' 
+ '      sum\n' 
+ '    else \n' 
+ '      let (f, fs) = fs in \n' 
+ '      g (deref {x}) (f x + sum) fs\n' 
+ '  in\n' 
+ '  aux x 0 fs\n' 
+ 'in \n' 
+ '\n' 
+ 'let avg3 = λx. \n' 
+ '   let w = λx. x / 3 in \n' 
+ '   let fs = (w, (w, (w, nil))) in\n' 
+ '   fir x fs\n' 
+ 'in\n' 
+ '\n' 
+ 'let inp = {0} in \n' 
+ 'link inp ((deref inp) + 1); \n' 
+ 'let y = avg3 (deref inp) in\n' 
+ 'step; \n' 
+ 'step; \n' 
+ 'step; \n' 
+ 'peek y\n' 


/* without pairs 
var fir_ex =
  'let pair = λx.λy.λz.z x y in\n'
+ 'let fst = λp.p (λx.λy.x) in\n'
+ 'let snd = λp.p (λx.λy.y) in\n'
+ '\n'
+ 'let nil = pair true true in \n'
+ 'let isnil = fst in \n'
+ 'let cons = λh.λt. pair false (pair h t) in\n'
+ 'let head = λz. fst (snd z) in\n'
+ 'let tail = λz. snd (snd z) in \n'
+ '\n'
+ 'let fir = rec g. λx. λl.\n'
+ '  if isnil l \n'
+ '  then \n'
+ '    pair x 0\n'
+ '  else \n'
+ '    let f = head l in \n'
+ '    let fs = tail l in \n'
+ '    let result = g x fs in \n'
+ '    let s = {0} in \n'
+ '    let _ = link s to deref (fst result) in \n'
+ '    pair s (f s + (snd result))\n'
+ 'in \n'
+ '\n'
+ 'let avg3 = λx. \n'
+ '   let w = λx. x / 3 in \n'
+ '   let l = cons w (cons w (cons w nil)) in\n'
+ '   snd (fir x l)\n'
+ 'in\n'
+ '\n'
+ 'let inp = {0} in \n'
+ 'avg3 inp\n'
*/

var iir_ex = 
  'let nil = 0 in\n'
+ 'let iir = λx. λffw. λfbw.\n'
+ '  let forward = rec g. λx. λl.\n'
+ '    if l <= nil\n' 
+ '    then \n'
+ '      (x, 0)\n'
+ '    else \n'
+ '      let (f, fs) = l in \n'
+ '      let (inp, sum) = g x fs in \n'
+ '      let s = {0} in \n'
+ '      link s inp; \n' 
+ '      (s, (f s + sum)) \n'
+ '  in \n'
+ '  let backward = rec g. λx. λl.\n'
+ '    if l <= nil\n' 
+ '    then \n'
+ '      (x, (x, nil))\n'
+ '    else \n'
+ '      let (f, fs) = l in \n'
+ '      if fs <= nil\n'
+ '      then \n'
+ '        let s = {0} in\n'
+ '        link s x; \n'
+ '        (s, ((x - f s), s))\n'
+ '      else\n' 
+ '        let (out, sum) = g x fs in \n'
+ '        let (sum, inp) = sum in\n'
+ '        let s = {0} in \n'
+ '        link s out; \n' 
+ '        (s, ((sum - f s), inp))\n'
+ '  in \n'
+ '  let (_, out) = forward x ffw in\n'
+ '  let (_, out) = backward out fbw in\n' 
+ '  let (out, inp) = out in\n'
+ '  if inp <= nil\n' 
+ '  then out\n'
+ '  else \n'
+ '    link inp out; out\n'
+ 'in\n'
+ '\n'
+ 'let test = λx. \n'
+ '   let w = λx. x / 3 in \n'
+ '   let l = (w, (w, (w, nil))) in\n' 
+ '   let out = iir x l l in\n' 
+ '   out\n'
+ 'in\n' 
+ '\n'
+ 'let inp = {0} in \n'
+ 'link inp ((deref inp) + 1); \n'
+ 'let y = test (deref inp) in\n' 
+ 'step; \n'
+ 'step; \n'
+ 'step; \n'
+ 'peek y\n'  

var rsum_ex =
  'let signal =  \n' 
+ '  let s = {1} in\n'
+ '  link s ((deref s) + 1); \n' 
+ '  s\n'
+ 'in\n'
+ '\n'
+ 'let rsum = λi. \n' 
+ '  let s = {0} in\n'
+ '  link s ((deref s) + i); \n'
+ '  s\n'
+ 'in\n'
+ '\n'
+ 'let o = rsum (deref signal) in\n' 
+ 'step; \n'
+ 'step; \n'
+ 'step; \n'
+ 'step; \n'
+ 'step; \n'
+ 'step; \n'
+ 'o'; 


var linear_regression_ex = 
  'let set = λx.λy. \n' 
+ '  link x y; \n'
+ '  assign x y \n'
+ 'in \n'
+ ' \n'
+ 'let gradient_descent = Λa.λm.λps.λloss. \n'
+ '  let rate = 0.001 in  \n'
+ '  let d = 0.001 in  \n'
+ '  let old_ps = peek (deref[a] ps) in  \n'
+ '  let g = λe. \n'
+ '    let old_loss = loss m in  \n'
+ '    assign[a] ps (old_ps ⊞[a] (d ⊠[a] e));  \n'
+ '    let new_loss = loss m in  \n'
+ '    (((old_loss - new_loss) / d) * rate) ⊠[a] e  \n'
+ '  in  \n'
+ '  assign[a] ps  \n'
+ '         (fold[a] (λe.λps.(g e) ⊞[a] ps) old_ps) \n'
+ 'in \n'
+ ' \n'
+ 'let sq = λx.x * x \n'
+ 'in \n'
+ ' \n'
+ 'let x = {0} in  \n'
+ 'let y = (deref x) * (pc 1) + (pc 0) in  \n'
+ ' \n'
+ 'let loss = λy.  \n'
+ '  set x 0; \n'
+ '  let y1 = peek y in  \n'
+ '  set x 2; \n'
+ '  let y2 = peek y in  \n'
+ '  ((sq (10 - y1)) + (sq (12 - y2))) / 2 \n'
+ 'in \n'
+ ' \n'
+ 'fuse(a) ps from y in  \n'
+ 'gradient_descent[a] y ps loss;  \n'
+ 'set x 10;  \n'
+ 'peek (deref y)  \n';

var fusion_ex = 
  'let x = {pc 1} in \n' 
+ 'let y = x + pc 2 in\n'
+ 'let z = pc 3 + x in\n'
+ 'fuse(a) ps from y in\n'
+ 'fuse(b) qs from z in\n' 
+ 'x'; 